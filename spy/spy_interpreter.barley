-module(spy_interpreter).

master(Tree) ->
    Result = "# Generated by SPY\n\n",
    (Result = Result + eval_master(Part)) || Part -> Tree,
    Result.

eval_master(Part) when Part[0] == types:as_atom("not") ->
    eval_not(Part).
eval_master(Part) -> eval(Part).

eval_not([Atom, Expr]) ->
    "not " + eval_master(Expr).

eval_tokens(Tokens) ->
    string:join(eval_master(Token) || Token -> Tokens, "").


eval([return, RetExpr]) ->
    "return " + eval_master(RetExpr).
eval([lambda, LMArgs, LMBlock]) ->
    "lambda " + eval_tokens(LMArgs) + ":" + eval_master(LMBlock).
eval([fdef, FDName, FDArgs, FDBlock]) ->
    FDArgs = eval_tokens(FDArgs),
    "def " + FDName + FDArgs + ":" + eval_master(FDBlock).
eval([if_else, IEExpr, IEBlock, IEElseBody]) ->
    IEExprStr = eval_tokens(IEExpr)
    IEResult = "if " + IEExprStr + ":" + eval_master(IEBlock),
    not (IEElseBody == empty) ? IEResult = IEResult + "else:" + eval_master(IEElseBody) :: skip,
    IEResult.
eval([from_add, FAModule, FAFun]) ->
    "from " + FAModule + " import " + FAFun.
eval([incr, IExpr]) ->
    eval_master(IExpr) + " = " + eval_master(IExpr) + " + 1".
eval([decr, DExpr]) ->
    eval_master(DExpr) + " = " + eval_master(DExpr) + " - 1".
eval([call, CLExpr, CLArgs]) ->
    CLArgsExpr = eval_tokens(CLArgs),
    eval_master(CLExpr) + "(" + CLArgsExpr + ")".
eval([for_legacy, FLName, FLInit, FLCondition, FLTerm, FLBody]) ->
    FLTermExpr = eval_tokens(FLTerm),
    FLResult = "",
    FLResult = FLResult + FLName + " = " + eval_master(FLInit) + "",
    FLResult = FLResult + "while " + eval_master(FLCondition) + ":",
    FLResult = FLResult + eval_master(FLBody) + "",
    FLResult = FLResult + "    " + FLTermExpr,
    FLResult.
eval([for_in, FName, FExpr, FBody]) ->
    FAccExpr = eval_tokens(FExpr),
    "for " + FName + " in " + FAccExpr + ":" + eval_master(FBody).
eval([group, GExprs]) ->
    GAcc = "(",
    GAcc = GAcc + eval_tokens(GExprs),
    GAcc = GAcc + ")",
    GAcc.
eval([block, BExprs]) ->
    string:join(eval_master(BExpr) || BExpr -> BExprs, "").
eval([while, WExpr, WBody]) ->
    "while " + eval_master(WExpr) + ":" + eval_master(WBody).
eval([or_expr, OLeft, ORight]) ->
    "(" + eval_master(OLeft) + " and " + eval_master(ORight) + ")".
eval([and_expr, ALeft, ARight]) ->
     "(" + eval_master(ALeft) + " and " + eval_master(ARight) + ")".
eval([out, OOExpr]) ->
    "(print(" + eval_master(OOExpr) + "))".
eval([input, IExpr]) ->
    "(input(" + eval_master(IExpr) + "))".
eval([space]) -> " ".
eval([newline]) -> "\n".
once([tab]) -> "\t".
eval([id, Symbol]) -> Symbol.
eval([assign, AName, AExpr]) ->
    AName + " = " + eval_master(AExpr).
eval([binary_op, BOp, BLeft, BRight]) ->
    eval_master(BLeft) + " " + BOp + " " + eval_master(BRight).
eval([unary_op, UOp, UOperand]) ->
    "(" + UOp + eval_master(UOperand) + ")".
eval([add, AModule]) ->
    "import " + AModule.
eval([string, SStr]) -> "\"" + SStr + "\"".